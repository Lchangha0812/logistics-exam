# 식자재 기반 입출고 관리 프로젝트

## 프로젝트 개요

이 프로젝트는 WMS(Warehouse Management System)의 일부 핵심 기능을 단순화하여 구현한 입·출고 관리용 REST API 서버이다. 재고를 SKU 단위로 관리하며, 품목 정보, 단위(UoM), 온도대, 카테고리 등 기본적인 물류 도메인을 포함한다. 현재로썬느 JPA를 사용하여 영속성을 구현하되, 도메인 모델과 인프라 모델을 분리한 구조를 적용하였다.

애플리케이션은 학습 목적의 포트폴리오 프로젝트로, **도메인 모델링(OOP 기반), 계층 분리, 영속 기술 독립성** 같은 구조적 결정을 실제 코드에 적용하는 데 중점을 두고 있다. REST API 형태로 제공되며, Spring Boot를 기반으로 전체적인 백엔드 구성을 갖추고 있다.


## 설계 의도 및 아키텍처 결정

이 프로젝트는 WMS 일부 기능을 단순화하여 구현한 입·출고 관리 REST API 서버로,
도메인 모델링, 계층 경계 설정, 영속 기술 선택과 분리 등을 실험적으로 적용한 구조를 가진다.
아래 내용은 개발 과정에서 고려한 핵심 설계 의도와 선택 이유를 정리한 것이다.


### 1. 계층 경계 및 Web–Application–Infrastructure 의존성 기준

여러 프로젝트를 진행하면서 고민했던 것 중 **계층 간 어떤 타입이 어느 레이어에까지 영향을 미쳐도 되는가** 가 있었다.

CRUD 중심 요구사항에서는 Web 레이어의 Request/Response 구조가 Application 계층의 입력/출력과 거의 동일했다. 따라서 Web과 Application은 요구사항 기반으로 강한 결합을 인정했고, Request·Response DTO를 Service 계층에서 그대로 사용하도록 설계했다.  CRUD 요구사항에 별도의 DTO를 만드는 것은 의미 있는 이점이 없다고 판단했다.

반면 Application과 Infrastructure는 역할 특성과 개발 단계에서의 불확실성 때문에 명확한 분리가 유리하다고 판단했다. 영속 기술(JPA, JDBC, MyBatis 등)을 처음부터 결정하지 않았기 때문에 Application 계층은 `Repository`, `IdGenerator` 등 외부 기능을 추상화하는 Contract만 정의하고, 실제 구현은 Infrastructure 계층에서 맡도록 구조를 분리했다.

Spring Data의 `Page<T>`가 전 계층으로 퍼지는 것을 방지하기 위해 `PageResult`(Application 경계)와 `PageResponse`(Web 경계)를 별도로 정의한 것도 같은 맥락이다. 실용적 선택이라기보다는 프레임워크 타입이 전체 계층을 오염시키지 않도록 하기 위한 구조적 실험에 가깝다.

### 2. 도메인 모델의 ‘완전한 POJO’ 추구 대신 현실적 독립성 선택

도메인 모델은 이론적으로 프레임워크 의존 없이 완전한 POJO 형태로 만드는 것이 이상적이다.
하지만 이 프로젝트에서는 **완전한 순수성보다 현실적인 유지보수 비용**을 기준으로 삼았다.

도메인 모델은 인프라·웹 기술과는 완전히 분리했지만, Lombok과 Spring의 `Assert`는 의도적으로 허용했다. 이는 다음과 같은 판단에 따른 것이다.

1. 이 도메인을 **Spring이 없는 환경으로 옮길 가능성은 낮다.**
2. 혹시 이식하게 되더라도 Lombok 제거 및 Assert 대체 비용은 **매우 낮다.**
3. Lombok을 배제하면 도메인 코드 전체가 보일러플레이트로 오염되고 가독성이 떨어진다.
4. Spring Assert는 도메인 규칙을 간결하고 명확하게 표현하게 해주며, 불필요한 예외 계층을 만들지 않아도 된다.

개인적으로 도메인익셉션과 관련 유틸을 작성해서 사용해 봤지만 자바가 제공하는 `IllegalStateException`, `IllegalArgumentException` 가 좀 더 명확하다고 판단했다.
즉, 도메인의 목적을 Spring 기반 백엔드 환경에서 인프라 기술과 독립된 도메인 모델”로 두는 것이 비용 효율적이라고 판단하였다.

---

### 3. 영속 모델(Entity)과 도메인 모델 분리

도메인 모델링은 영속 기술이 완전히 확정되기 이전에 먼저 진행되었다.
데이터베이스나 특정 영속 기술이 초기에는 명확하지 않았기 때문에
도메인을 영속 모델에 결합시키는 것은 구조적으로 부적절하다고 판단하였다.

JPA 선택 이후에도 엔티티와 도메인을 통합하지 않은 이유는 다음과 같다.

#### JPA 엔티티는 OOP 기반 도메인 모델링에 제약을 걸기 때문

1. 기본 생성자 강제와 Setter 또는 필드 변경 허용 구조 강제가 객체지향적인 설계를 방해했다.
2. 값 객체 불변성 구현 어려움이 있다.
3. 프록시 및 LAZY 로딩같은게 도메인 설계에 있어 걸림돌이 되는경우가 있었다.
4. 식별자 규칙과 equals/hashCode 충돌

이러한 제약을 고려하며 객체 모델링 하는게 오히려 비용이 높다고 판단햇다.

반면 엔티티 ↔ 도메인 매핑은 **명확한 책임 분리**와 **기술 독립성**을 제공하며
장기적으로 유지보수 비용을 오히려 크게 낮춘다고 생각했다.

결론적으로, 영속성과 비즈니스 모델은 명확히 분리하는 것이
전체 비용 관점에서 더 합리적이라고 판단했다.

## 개발 환경

- 언어: Java 21
- 프레임워크: Spring Boot 3.5
    - Spring Web
    - Spring Data JPA
    - QueryDsl
    - Spring Validation
    - Lombok
    - Mapstruct
- 빌드 툴: Gradle
- 데이터베이스: 미정 (PostgreSQL / Redis 검토중)
- 인프라:
    - 배포: 개인 온프레미스 서버 (Linux 기반)
    - 런타임: Docker (미정)
    - Nginx (React 정적 파일 서빙 및 백엔드 어플리케이션 리버스 프록시)
- 개발 도구:
    - IntelliJ IDEA
    - Git / GitHub
    - Postman

## 개발 이력 및 계획

- 10월 30일: 프로젝트 개발 시작
- 11월 9일: 프로세스 중심 모델(WMS 입하–입고–검품–출고)에서  
  문서 기반 모델(WMS 실제 문서 구조)로 방향 전환
- 11월 11일: 마스터데이터 기능 구현 완료
- 현재 진행: 입고 관련 문서 모델링 및 기능 구현
